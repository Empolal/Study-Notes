- [问题一：为什么需要拷贝构造函数，如何调用和声明？](#问题一为什么需要拷贝构造函数如何调用和声明)
    - [拷贝构造函数的声明:](#拷贝构造函数的声明)
    - [调用情景:](#调用情景)
- [问题二：值传递和引用传递的区别](#问题二值传递和引用传递的区别)
    - [引申：引用传递和指针传递的区别](#引申引用传递和指针传递的区别)
- [问题三：浅拷贝与深拷贝的区别](#问题三浅拷贝与深拷贝的区别)
- [问题四：赋值运算符的声明、定义与调用？与拷贝构造函数的区别](#问题四赋值运算符的声明-定义与调用与拷贝构造函数的区别)

1.  <u>赋值运算符的定义与调用</u>？ 第10<u>章没找到</u>

## 问题一：为什么需要拷贝构造函数，如何调用和声明？

### 拷贝构造函数的声明:

```c++
ClassName ClassName(const ClassName &);
```

### 调用情景:

- 对象作为函数的参数，以值传递的方式传给函数。
- 对象作为函数的返回值，以值的方式从函数返回。
- 使用一个对象给另一个对象初始化。

## 问题二：值传递和引用传递的区别

值传递和引用传递的形式：

```c++
void callme1(stringbad & r);//pass by reference
void callme2(stringbad r);// pass by value
```

首先类对象在创建时会调用构造函数，在释放时会调用析构函数
如果函数参数是采用值传递的方式传入类对象，则由于值传递的性质，先调用类复制构造函数产生一个临时对象，然后在函数返回后会因为弹栈来释放内存，即会调用类析构函数将该临时对象内存释放；即对象在值传递时，会比引用传递多调用一次构造和析构函数。

所以拷贝构造函数也采用引用传递的形式，而不是值传递。

#### 引申：引用传递和指针传递的区别

指针传递传递的是地址，指针在逻辑上是独立的，它可以被改变的，包括指针变量的值（所指向的地址）和指针变量的值对应的内存中的数据（所指向地址中所存放的数据）。

引用传递本质上wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww

## 问题三：浅拷贝与深拷贝的区别

为了回答第3个问题，首先请看下面代码

假设已经定义了`stringbad`类

```c++
#include "stringbad.hpp"

void callme1(stringbad & rsb);//pass by reference
void callme2(stringbad r);// pass by value
using std::cout;

int main()
{
    stringbad sports("Spinach leaves bowl for dollars");
    stringbad sailor = sports;//出现乱码是因为调用了默认拷贝构造函数，而没有更新static变量，以及指针变量
    cout<<"拷贝构造的输出: "<<sailor<<std::endl;//为什么可以以对象名字来作字符串的输出
    
    stringbad knot;
    knot= sports;//出现乱码是因为调用了默认赋值运算，却没有更新static变量和指针变量
    cout<<"赋值运算符的输出："<<knot<<std::endl;
    return 0;
}

void callme1(stringbad &rsb)
{
    cout<<"pass by reference:\n";
    cout<<rsb.print_static()<<"\""<<rsb<<"\"\n";
}

void callme2(stringbad r)
{
    cout<<"pass by value:\n";
    cout<<r.print_static()<<"\""<<r<<"\"\n";
}
```

以上代码输出结果异常的原因是由C++ 特殊成员函数引起的。这些成员函数是自动定义的，具体如下

- 默认构造函数，如果没有定义
- 默认析构函数，如果没有定义
- 复制构造函数，如果没有定义
- 赋值运算符函数，如果没有定义
- 地址运算符函数，如果没有定义

将对像赋给另一个对象，若没有定义赋值运算符和拷贝构造函数，编译器会提供默认赋值运算符的定义或复制构造函数，进行的是浅拷贝。

若对象里含有指针成员，浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。对静态成员不拷贝。

所以浅拷贝会对含有指针成员的对象造成内存泄漏，在进行对象赋值时最好定义了拷贝构造函数<u>并对指针成员另外开辟内存。</u>

## 问题四：赋值运算符的声明、定义与调用？与拷贝构造函数的区别

首先，定义一个赋值运算符时需要考虑以下四点：

1、把返回值声明为该类型的引用，并在函数结束时前返回实例自身的引用（*this）。只有返回一个引用，才可以允许连续赋值。
2、传入的参数需要声明为常量引用。如果传入的参数不是引用而是实例，则从形参到实参会调用一次复制构造函数，造成无谓消耗。
3、释放实例自身已有的内存。如果在分配新内存前忘记释放自己已有的内存，则会出现内存泄漏。
4、判断传入参数与当前实例是不是同一个实例。如果是同一个，则立即返回。如果事先不判断会导致严重问题：当/*this和传入参数是同一个实例，一旦释放了自身的内存，传入的参数的内存便也就同时被释放了，后续再也找不到需要赋值的内容了。

声明：

```c++
返回对象 & operator=(const ClassName & s);//传入参数必须为类名才能成为编译器默认的赋值运算符函数
```

定义：

```c++
stringbad & stringbad::operator=(const stringbad & s)//返回引用提高效率
{
    if(this==&s)//防止对自生赋值
        return *this;
    delete [] str;//防止内存泄漏
    len=s.len;
    str=new char [len+1];
    strcpy(str,s.str);
}
```

调用：
拷贝构造函数和赋值运算符的行为比较相似，却产生不同的结果；拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。

区分：
是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。
另外在深度拷贝时，注意指针和静态类成员。