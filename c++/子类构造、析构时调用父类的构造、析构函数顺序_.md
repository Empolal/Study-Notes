析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。

而**定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。**

原因：

1. 派生类构造函数中的某些初始化可能是基于基类的，所以规定构造在类层次的**最根处**开始，而在**每一层，首先调用基类构造函数，然后调用派生类对象构造函数**（因为C++的成员变量是不会自动初始化的，只能使用初始化列表初始化或在本层构造函数内初始化）
   <u>注意：调用成员的构造函数，如果不在初始化列表中显式调用的话，则会隐式调用成员变量的默认构造函数</u>
2. 如果没有显式调用基类的构造函数，会自动调用基类的无参构造函数。而如果基类只有带参数的构造函数，则会报错。不一定要显式的无参构造函数，可以显式调用基类带参数的构造函数。

```c++
class A
{
private:
    int zhengshu;
public:
    A(int a):zhengshu(a){std::cout<<zhengshu<<std::endl;};
    ~A();
    void init(int a);
    int print();
};

class B: public A
{
    public:
    B(int a):A(a){//如果没有显示的调用基类有参构造函数，会调用基类无参构造函数，则会报错
    }
};
```

