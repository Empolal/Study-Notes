- [x] 多态是什么
    
- [ ] 如何实现
    
- [ ] 引用和指针与多态的关系
    
- [x] 虚函数与多态
    
- [ ] 类类指针与类对象
    

- [静态多态](#静态多态)
- [动态多态](#动态多态)
    - [动态多态的条件：](#动态多态的条件)
- [抽象类](#抽象类)
- [虚函数表和虚函数指针](#虚函数表和虚函数指针)

## 静态多态

==静态多态：==函数重载是一种简单的静态多态

==静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错==

## 动态多态

==动态多态：== 显然这和静态多态是一组反义词，它是在==程序运行时==根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。

### 动态多态的条件：

- 基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行==重写==。
- 通过基类对象的指针或者引用调用虚函数。

（）（实现一个）（）（）（）（）（）（）（）（）（）（）（）（）（）（（）（）（）

==重写 ：==
（a）基类中将被重写的函数必须为虚函数（上面的检测用例已经证实过了）
（b）基类和派生类中虚函数的原型必须保持一致（返回值类型，函数名称以及参数列表），==协变==和析构函数（基类和派生类的析构函数是不一样的）除外
（c）访问限定符可以不同

那么问题又来了，什么是==协变==？
协变：基类（或者派生类）的虚函数返回基类（派生类）的指针（引用）

总结一道面试题：那些函数不能定义为虚函数？
经检验下面的几个函数都不能定义为虚函数：
1）友元函数，它不是类的成员函数
2）全局函数
3）静态成员函数，（它没有this指针）
4）构造函数，拷贝构造函数，以及赋值运算符重载（不是不能，而是没意义）

构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。
虚函数的存在是因为编译期间没法确定具体调用对象，才会有虚函数，虚函数表这么个东西。

## 抽象类

```c++
class Bus
{
public:
    virtual void TakeBusToSomewhere(TakeBus& tb) = 0;  //？？？为什么要等于0
};
```

在成员函数(必须为虚函数)的形参列表后面写上=0，则成员函数为==纯虚函数==。包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。纯虚函数在派生类中重新定义以后，派生类才能实例化出对象。纯虚函数是一定要被继承的，否则它存在没有任何意义。

## 虚函数表和虚函数指针

![虚函数表](https://gitee.com/empolal/blog-image/blob/master/c++/xuhanshubiao.png)

虚指针大小适系统编译器确定

```c++
class Base {
public:
    virtual void Funtest1(int i) {
        cout << "Base::Funtest1()" << endl;
    }
    /==一般64位的amd编译器默认8个字节对齐
     * 32位的x86编译器默认4个字节对齐
     * 虚指针大小所以为8字节==/
    int _data;
};

int main() {
    cout << sizeof(Base) << endl;
    Base b;
    b._data = 10;
    return 0;
}
```